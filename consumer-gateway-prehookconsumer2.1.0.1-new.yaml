global-policy: 1.0.0

info:
  name: consumer-gateway-prehook
  title: consumer-gateway-prehook
  version: consumer2.1.0.1

gateways:
  - datapower-api-gateway

assembly:
  execute:
    - gatewayscript:
        version: 2.0.0
        title: gws-dhcg-init
        source: "/* -------------------Code Header -------------------------------\n          Filename: dhcg-init.js\n          Version: 1.1.1\n          Last Updated: \n          June 5, 2020 - removed app-querystring as a best practice.\n          June 1, 2020 - upgrade to 4.1.11 - this file copies the query string parameter into the request.querystring to avoid having to update apis.\n          Oct. 25, 2019 - gtwy mode\n          Jan 11, 2019 - GtwyClientIP added to headers to pass thru\n          Jan 7, 2019 - changed ets to ts, and added relates_to, http_response_phrase\n\n\n          Description: \n          This script is used to define runtime variables such as allowable clock skews etc..  \n\n\n\n          **************************************************************\n            Copyright (c) ehealthOntario, 2018\n\n            This unpublished material is proprietary to ehealthOntario.\n            All rights reserved. Reproduction or distribution, in whole \n            or in part, is forbidden except by express written permission \n            of ehealthOntario.\n          **************************************************************\n          -------------------------------------------------------------------*/\n//var serviceVars = require('service-metadata'); - does not work in apic even if it works in pure gatewayscript\nvar console = require('console');\nvar apim = require('apim');\nvar lcategory = context.get('api.properties.log-category');\nvar logger = console.options({ 'category': lcategory });\nvar testmode = context.get('api.properties.test');\nvar compatibilitymode = context.get('api.properties.compatibilitymode');\nvar privacyIndicator = context.get('api.properties.privacy-preserving-enabled');\n\n/* fallback parameters */\nvar configurationObject =\n{\n    'clockSkewSec': 300,\n    'loglevel': 'error',  // setting to error for easy debugging, in prod this should be info\n    'test_mode': (testmode != null),\n    'maxTokenLifeSec': 3600,\n    'compatibilitymode': (compatibilitymode!=null)\n};\n\n// set test mode\n\n// compute request size\nvar reqSizeTemp = context.get('request.headers.content-length');\nvar contentLength = 0;\nif (reqSizeTemp) {\n    contentLength = parseInt(reqSizeTemp);\n}\n\n\n\nvar templateLog = {\n    'relates_to': null,\n    'op': context.get('api.root') + context.get('api.operation.path'),\n    'ts': null,\n\n    'global': { 'GtwyTxId': context.get('message.headers.x-global-transaction-id') },\n    'tags': {\n        'component': 'gateway',\n        'instance': context.get('api.endpoint.address'),\n        'client_ip': context.get('request.headers.x-forwarded-for'),\n        'http_method': context.get('request.verb'),\n        'http_status_code': null,\n        'http_response_phrase': null,\n        'request_size': contentLength,\n        'application_certificate_Subject': context.get('application.certificate.Subject'),\n        'application_certificate_Issuer': context.get('application.certificate.Issuer'),\n        'apic': {\n            'plan_id': context.get('plan.id'),\n            'client_app_name': context.get('client.app.name'),\n            'apim-tx-id': context.get('message.headers.x-global-transaction-id')\n        },\n        'error': false,\n        'errorcode': null,\n        'errordetails': null,\n    },\n\n\n};\n\n// setup the privacy preserving status, which will decide to go regular JTW validation or RSAdapter validation\nif( 'true' === privacyIndicator ) {\n    context.set('privacy_preserving_enabled', 'true')\n}\nelse {\n    context.set('privacy_preserving_enabled', 'false')\n}\nlogger.debug('CG-PREHOOK: prehook-src.js api property privacy-preserving-enabled is ' + privacyIndicator );\nlogger.debug('CG-PREHOOK: prehook-src.js context variable privacy-preserving-enabled is ' + context.get('privacy_preserving_enabled'));\n\n\ncontext.set('dhcg-configuration', configurationObject);\ncontext.set('dhcg-logging', templateLog);\n// needed for gtwy mode have to put into context\ncontext.set('GtwyTxId', context.get('message.headers.x-global-transaction-id'));\n// get the client transaction id \ncontext.set('ClientTxId', context.get('request.headers.x-request-id'));\n\n// blanking out the header fields.\ncontext.set('G_CLIENT_IP', apim.getvariable('message.headers.X-Client-IP'));\n\n//context.set('log.request_http_headers.X-Gtwy-Client-Secret', \"******\");\n\n//context.set('log.request_http_headers.Authorization', \"******\");"
    - gatewayscript:
        version: 2.0.0
        title: jwt-validation
        source: "/* ---------------------Code Header -------------------------------\nFilename: validatejwt.js\nVersion: 3.0.0\n\nLast update:\nDec 5,   Updated to support P/D validation in the usertype claims\nNov 26, Updated to support V2 token updated Nov22 on confluence.\nNov 14, 2019 - combined the validation of the auth error into this source\n            for efficieny and separation of concerns, the hook doesn't need to\n            know too much about auth errors.\nNov 4, 2019  - Cosumer V2 functionality\nOct 23, 2019\n   Convert to gateway mode context variables \nJan 11, 2019\n- Future token check added iat in future will not be accepted.\nJan 9 , 2019 \n-modified raiseError to not put in error code, that is resolved later\n-used ISO format for date error messages\n\nDec 21, 2018\n-added typ, alg , and iat validation\nDescription: \n1)Extract Headers\n2)Reformat the x5t field into base64 by changing the - and _ characters and\n  pad to a multiple of 4 with the = characters\n3) Validate claims\n  \nAuthor: Michael Hui\n\n\n\n**************************************************************\n  Copyright (c) ehealthOntario, 2019\n\n  This unpublished material is proprietary to ehealthOntario.\n  All rights reserved. Reproduction or distribution, in whole \n  or in part, is forbidden except by express written permission \n  of ehealthOntario.\n**************************************************************\n-------------------------------------------------------------------*/\nvar jose = require('jose');\nvar jwt = require('jwt');\nvar console = require('console');\n\nvar dhcgconfig = context.get('dhcg-configuration');\nvar lcategory = context.get('api.properties.log-category');\nvar logger = console.options({ 'category': lcategory });\n\n\n\n\n/* --------ERROR ref_code DEFINITION BLOCK -------------------------------*/\nvar errorref_codes = {\n    'AUTHORIZATION_JWT_NE': {\n\n        'ref_code': 'GTWY-ATH10',\n        'details': 'Token Not in Request',\n        'status': {\n            'code': '400',\n            'reason': 'Bad Request',\n        },\n        'kind': 'AE',\n        'body': 'Token Not in Request'\n\n    },\n    'AUTHORIZATION_JWT_INVALIDTOKENFORMAT': {\n        'ref_code': 'GTWY-ATH11',\n        'details': 'Token does not contain the verfication certificate thumbprint',\n        'status': {\n            'code': '400',\n            'reason': 'Bad Request'\n        },\n        'kind': 'AE',\n        'body': ''\n    },\n    'AUTHORIZATION_JWT_SIGNATUREVALIDATION': {\n        'ref_code': 'GTWY-ATH12',\n        'details': 'Token signature cannot be verified',\n        'status': {\n            'code': '401',\n            'reason': 'Unauthorized'\n        },\n        'kind': 'AE',\n        'body': 'Token signature cannot be verified'\n    },\n    'AUTHORIZATION_JWT_SYSCONFIG': {\n        'ref_code': 'GTWY-SYSF0',\n        'details': 'Cannot Validate JWT Signature, Certificate Registry Issue',\n        'status': {\n            'code': '500',\n            'reason': 'Internal System Error'\n        },\n        'kind': 'SE',\n        'body': 'Cannot Validate JWT Signature, Certificate Registry Issue'\n    },\n    'AUTHORIZATION_JWT_CLAIMS': {\n        'ref_code': 'GTWY-ATH13',\n        'details': 'One or more claims in Token could not be verified',\n        'status': {\n            'code': '401',\n            'reason': 'Unauthorized'\n        },\n        'kind': 'AE',\n        'body': ''\n    },\n    'AUTHORIZATION_JWT_TOKENEXPIRED': {\n        'ref_code': 'GTWY-ATH14',\n        'details': 'Token is expired',\n        'status': {\n            'code': '401',\n            'reason': 'Unauthorized'\n        },\n        'kind': 'AE',\n        'body': ''\n    },\n    'AUTHORIZATION_JWT_TOKENLIFETOOLONG': {\n        'ref_code': 'GTWY-ATH15',\n        'details': 'Token is life time too long',\n        'status': {\n            'code': '401',\n            'reason': 'Unauthorized'\n        },\n        'kind': 'AE',\n        'body': ''\n    },\n    'AUTHORIZATION_JWT_TOKENFUTURE': {\n        'ref_code': 'GTWY-ATH16',\n        'details': 'Token was created for the future',\n        'status': {\n            'code': '401',\n            'reason': 'Unauthorized'\n        },\n        'kind': 'AE',\n        'body': ''\n    },\n    'SYSTEMCONFIG': {\n        'ref_code': 'GTWY-SYSF1',\n        'details': 'DHCG System configuration invalid',\n        'status': {\n            'code': '500',\n            'reason': 'System Internal Error'\n        },\n        'kind': 'SE',\n        'body': ''\n    },\n    'SYSTEMASYNC': {\n        'ref_code': 'GTWY-SYSF2',\n        'details': 'System configuration invalid Claim Validation Async error',\n        'status': {\n            'code': '500',\n            'reason': 'System Internal Error'\n        },\n        'kind': 'SE',\n        'body': ''\n    }\n};\n/* --------END ERROR ref_code DEFINITION BLOCK -------------------------------*/\n\nvar outputClaims = {};\nconst validusertypes = [\"P\", \"D\"];\n\nconst validatePromise = new Promise((resolve, reject) => {\n    validateJWT(resolve, reject);\n});\n\nfunction onResolved() {\n    logger.debug(\"CG-PREHOOK: validatejwt.js on Resolved\");\n    var authPassed = {\n\n        'status': {\n            'code': '200',\n            'reason': 'OK'\n        },\n        'body': '',\n        'headers': {\n            'errorcode': '0000'\n        }\n    };\n    //context.set('auth-response', authPassed);\n    context.set('App-IntrospectionToken', outputClaims);\n}\n\nfunction onRejected(errorcode) {\n    logger.debug('CG-PREHOOK: validatejwt.js, onRejected Raising Error : ' + errorcode.ref_code + \" Details: \" + errorcode.body);\n    //context.set('auth-response', errorcode);\n    context.set('application.autherror', true);\n    context.set('application.errorcode', errorcode);\n}\n// some asynch ref_code is inside the above\n// going to lock it.\nvalidatePromise.then(onResolved, onRejected).catch(onRejected);\n\n\n\n/** This function has some internal locking to ensure asynch functions finish before returning \n * \n */\nfunction validateJWT(resolve, reject) {\n    // cut the bearer out\n\n\n    var jwtTokenBearer = context.get('request.authorization');\n    if (jwtTokenBearer == null || !jwtTokenBearer || jwtTokenBearer == '') {\n        reject(errorref_codes.AUTHORIZATION_JWT_NE);\n        return;\n    }\n\n    // if it not start with Bearer then another error\n\n    var jwtToken = jwtTokenBearer.split(\"Bearer \"); // the space is important\n    if (jwtToken.length < 2) {\n        reject(errorref_codes.AUTHORIZATION_JWT_NE);\n        return;\n    }\n\n    var jwsSignedObject = null;\n\n    try {\n        jwsSignedObject = jose.parse(jwtToken[1]);\n    } catch (err) {\n        logger.debug(\"CG-PREHOOK: validatejwt.js Error caught \" + err.message);\n        errorref_codes.AUTHORIZATION_JWT_INVALIDTOKENFORMAT.body = 'Error parsing jtwToken: System ' + err.message;\n        reject(errorref_codes.AUTHORIZATION_JWT_INVALIDTOKENFORMAT);\n        return;\n    }\n\n\n    var signedJWSHeaders = jwsSignedObject.getSignatures();\n\n    var x5t = null;\n    var typ = null;\n    var alg = null;\n    var x5tFound = false;\n    var certificateError = false;\n    var typFound = false;\n    var algFound = false;\n\n    for (var i = 0; i < signedJWSHeaders.length; i++) {\n        logger.debug(\"CG-PREHOOK: validatejwt.js Header index \" + i);\n        var hdr2 = signedJWSHeaders[i];\n        // Extract the value for the Header Parameter named 'kid'\n        var allHDR = hdr2.get();\n        //x5t = allHDR.x5t;\n        alg = allHDR.alg;\n        typ = allHDR.typ;\n        x5t = hdr2.get('x5t');\n\n        //alg = hdr2.get('alg');\n        if (x5t != null) {\n            if (x5t.startsWith('*') && x5t.endsWith('*')) {\n                // break out and error is set, this is a system error\n                certificateError = true;\n            } else {\n                var b64Thumbprint = base64urlToBase64(x5t);\n                if (!b64Thumbprint) {\n                    /* Throw an error up */\n                    errorref_codes.AUTHORIZATION_JWT_INVALIDTOKENFORMAT.body = \"Cannot convert x5t to base64: \" + x5t;\n                    reject(errorref_codes.AUTHORIZATION_JWT_INVALIDTOKENFORMAT);\n                    return;\n                }\n                var keyID = 'thumbprintsha1:' + b64Thumbprint;\n                hdr2.setKey(keyID);\n                x5tFound = true;\n                logger.debug(\"CG-PREHOOK: validatejwt.js key id: \" + keyID);\n            }\n        }\n\n        if (alg != null) {\n            algFound = true;\n            // validate it\n            logger.debug('CG-PREHOOK: validatejwt.js Token alg ' + alg);\n            if (alg != 'RS256') {\n                errorref_codes.AUTHORIZATION_JWT_INVALIDTOKENFORMAT.body = \"Token signature algorithm is not supported\";\n                reject(errorref_codes.AUTHORIZATION_JWT_INVALIDTOKENFORMAT);\n                return;\n            }\n        }\n        if (typ != null) {\n\n            typFound = true;\n            if (typ != 'JWT') {\n                errorref_codes.AUTHORIZATION_JWT_INVALIDTOKENFORMAT.body = 'Token type ' + typ + ' is not supported type';\n                reject(errorref_codes.AUTHORIZATION_JWT_INVALIDTOKENFORMAT);\n                return;\n            }\n\n        }\n\n        if (!x5tFound || !algFound || !typFound) {\n            var error_code = null;\n            var errorDetails = \"\";\n\n            if (certificateError) {\n                error_code = errorref_codes.AUTHORIZATION_JWT_SYSCONFIG;\n                error_code.body = x5t;\n\n            }\n            else {\n                error_code = errorref_codes.AUTHORIZATION_JWT_INVALIDTOKENFORMAT;\n                error_code.body = \"No x5t thumbprint or alg or typ found in JWT\";\n            }\n\n            reject(error_code);\n            return;\n        }\n    }\n\n\n    var myVerifier = jose.createJWSVerifier(jwsSignedObject);\n    logger.debug(\"CG-PREHOOK: validatejwt.js We've created the verifier\");\n    // Verify all signatures for which a key has been set\n    // At least one signature must have key set\n    // This valdiate is not asynchrohous as IBM documentation will have me beleive\n    // https://www.ibm.com/support/knowledgecenter/SS9H2Y_7.5.0/com.ibm.dp.doc/jose_js.html#JWSVerifier\n\n\n    myVerifier.validate(function (error) {\n        if (error) {\n            logger.debug(\"CG-PREHOOK: validatejwt.js Signature Validation Error\");\n\n            var error_code = errorref_codes.AUTHORIZATION_JWT_SIGNATUREVALIDATION;\n            error_code.body  += \" \" + error.errorCode;\n            reject(error_code);\n            //session.reject(error.errorMessage);\n        } else {\n            // All signature verifications have succeeded\n            // therefore payload may be trusted\n            var textClaims = jwsSignedObject.getPayload();\n            // write it into the next step\n            // do some claims validation\n            logger.debug('CG-PREHOOK: validatejwt.js Start Validating Claims');\n            var claimsObj = JSON.parse(textClaims);\n\n            // copy the claims into the outputclaims object\n            copyClaims(claimsObj);\n\n            // Check date time\n            // current date represented as Date()\n            // there are 2 possiblities the gateway clock is ahead or behind.\n            // when it is ahead tokens will appear to be exired\n            // when it is behind even tokens which are exired will still be accepted\n            // this logic treats the first case the 2nd case , the nbf or iat needs to be validated\n            // the skew configuration needs to be part of the api base set up\n\n            if (!dhcgconfig || !dhcgconfig.clockSkewSec || !dhcgconfig.maxTokenLifeSec) {\n                errorref_codes.SYSTEMCONFIG.body = \"skew or max token life not set\";\n                reject(errorref_codes.SYSTEMCONFIG);\n\n            } else {\n                var currentTime = new Date().getTime(); // this is in ms\n                // take maximum token life from api if there, otherwise use hook\n                var maxLife = dhcgconfig.maxTokenLifeSec;\n                var apiMaxTokenLife = context.get('maxTokenLifeSec');\n                if (apiMaxTokenLife) {\n                    maxLife = apiMaxTokenLife;\n                    logger.debug(\"CG-PREHOOK: validatejwt.js Using api defined max token life \" + maxLife);\n                }\n\n                // the actual test, need to check if it is a number and positive check the date format\n                if (!claimsObj.exp || typeof claimsObj.exp != 'number' ||\n                    claimsObj.exp < 0 ||\n                    !claimsObj.iat || typeof claimsObj.iat != 'number' || claimsObj.iat < 0) {\n                    errorref_codes.AUTHORIZATION_JWT_INVALIDTOKENFORMAT.body = \"No 'exp' and/or 'iat' claim found in token\";\n                    reject(errorref_codes.AUTHORIZATION_JWT_INVALIDTOKENFORMAT);\n\n                } else {\n                    if (currentTime - (claimsObj.exp * 1000) > (dhcgconfig.clockSkewSec * 1000)) {\n                        errorref_codes.AUTHORIZATION_JWT_TOKENEXPIRED.body = \"The token exp: \" +\n                            new Date(Number.parseFloat((claimsObj.exp * 1000).toPrecision(13))).toISOString() +\n                            \"  is before the current system time: \" + new Date(currentTime).toISOString();\n                        reject(errorref_codes.AUTHORIZATION_JWT_TOKENEXPIRED);\n                    } else if (!validateClaimType(claimsObj, 'exp', 0, true, 'number')) {\n                        errorref_codes.AUTHORIZATION_JWT_CLAIMS.body = \"invalid exp\";\n                        reject(errorref_codes.AUTHORIZATION_JWT_CLAIMS);\n                    } else if (!validateClaimType(claimsObj, 'iat', 0, true, 'number')) {\n                        errorref_codes.AUTHORIZATION_JWT_CLAIMS.body = \"invalid iat\";\n                        reject(errorref_codes.AUTHORIZATION_JWT_CLAIMS);\n                    }\n                    else if (claimsObj.exp - claimsObj.iat > maxLife) {\n                        errorref_codes.AUTHORIZATION_JWT_TOKENLIFETOOLONG.body = \"The life time is out of bounds\";\n                        reject(errorref_codes.AUTHORIZATION_JWT_TOKENLIFETOOLONG);\n                    } else if (currentTime - (claimsObj.iat * 1000) < (dhcgconfig.clockSkewSec * -1000)) {\n                        errorref_codes.AUTHORIZATION_JWT_TOKENFUTURE.body = \"The token issue time: \" +\n                            new Date(Number.parseFloat((claimsObj.iat * 1000).toPrecision(13))).toISOString() +\n                            \"  is after the current system time: \" + new Date(currentTime).toISOString();\n                        reject(errorref_codes.AUTHORIZATION_JWT_TOKENFUTURE);\n                    } else if (!validateClaimType(claimsObj, 'jti', 40, true, 'string')) {\n                        errorref_codes.AUTHORIZATION_JWT_CLAIMS.body = \"invalid jti\";\n                        reject(errorref_codes.AUTHORIZATION_JWT_CLAIMS);\n                    }\n                    else if (!validateClaimType(claimsObj, 'org', 70, false, 'string')) {\n                        errorref_codes.AUTHORIZATION_JWT_CLAIMS.body = \"invalid org\";\n                        reject(errorref_codes.AUTHORIZATION_JWT_CLAIMS);\n                    } else if (!validateClaimType(claimsObj, 'app', 50, true, 'string')) {\n                        errorref_codes.AUTHORIZATION_JWT_CLAIMS.body = \"invalid app\";\n                        reject(errorref_codes.AUTHORIZATION_JWT_CLAIMS);\n                    } else if (!validateClaimType(claimsObj, 'appVersion', 10, true, 'string')) {\n                        errorref_codes.AUTHORIZATION_JWT_CLAIMS.body = \"invalid appversion\";\n                        reject(errorref_codes.AUTHORIZATION_JWT_CLAIMS);\n                    } else if (!validateClaimType(claimsObj, 'sub', 0, true, 'string')) {\n                        errorref_codes.AUTHORIZATION_JWT_CLAIMS.body = \"invalid sub\";\n                        reject(errorref_codes.AUTHORIZATION_JWT_CLAIMS);\n                    } else if (!validateClaimType(claimsObj, 'idp', 255, true, 'string')) {\n                        errorref_codes.AUTHORIZATION_JWT_CLAIMS.body = \"invalid Idp\";\n                        reject(errorref_codes.AUTHORIZATION_JWT_CLAIMS);\n                    } else if (!validateClaimType(claimsObj, 'prn', 75, true, 'string')) {\n                        errorref_codes.AUTHORIZATION_JWT_CLAIMS.body = \"invalid prn\";\n                        reject(errorref_codes.AUTHORIZATION_JWT_CLAIMS);\n                    } else if (!validateClaimType(claimsObj, 'usertype', 1, true, 'string')) {\n                        errorref_codes.AUTHORIZATION_JWT_CLAIMS.body = \"invalid usertype\";\n                        reject(errorref_codes.AUTHORIZATION_JWT_CLAIMS);\n                    } else if (!validateClaimValueIsOneOf(claimsObj, 'usertype', validusertypes)) {\n                        errorref_codes.AUTHORIZATION_JWT_CLAIMS.body = \"invalid usertype values\";\n                        reject(errorref_codes.AUTHORIZATION_JWT_CLAIMS);\n                    }\n                    else if (!validateClaimType(claimsObj, 'aud', 255, true, 'string')) {\n                        errorref_codes.AUTHORIZATION_JWT_CLAIMS.body = \"invalid aud spec\";\n                        reject(errorref_codes.AUTHORIZATION_JWT_CLAIMS);\n                    }\n                    else {\n                        //validateClaims(jwtToken);\n                        resolve();\n                    }\n\n                }\n            }\n        }\n\n    });\n}\n\n\n\n/** Todo: this function should be included as part of an require module\n *  However, if we choose to do this, then deployments will be more complex because\n *  it will be a combination with file deployments\n */\nfunction base64urlToBase64(b64u) {\n    logger.debug(\"CG-PREHOOK: validatejwt.js base64urlToBase64: [\" + b64u + \"]\");\n    var pads = new Array(4);\n    pads[0] = '';\n    pads[1] = '===';\n    pads[2] = '==';\n    pads[3] = '=';\n    var b64uThumbprintNoPAD = b64u.replace(/-/g, '+').replace(/_/g, '/');\n    return b64uThumbprintNoPAD + pads[b64uThumbprintNoPAD.length % 4];\n\n}\n\nfunction copyClaims(claimsObj) {\n    for (var key in claimsObj) {\n        outputClaims[key] = claimsObj[key];\n    }\n}\n\n\nfunction validateClaimValue(obj, key, value) {\n    if (obj[key] == undefined) { return false; }\n    if (obj[key] != value) {\n        // check if array\n        var match = false;\n        if (obj[key] instanceof Object) {\n\n            for (var vind in obj[key]) {\n\n                if (obj[key][vind] == value) {\n                    match = true;\n                    break;\n                }\n            }\n            return match;\n        }\n        return false;\n    }\n    return true;\n}\n\nfunction validateClaimType(obj, key, maxlength, mandatory, typename) {\n    if (obj[key] != undefined) {\n        // check if array\n        if (typename == 'string') {\n            if (typeof obj[key] == typename) {\n                if( maxlength == 0 ) {\n                    return (obj[key].length >= 1);\n                }\n                else {\n                return (obj[key].length >= 1 && obj[key].length <= maxlength);\n                }\n            }\n        } else if (typename == 'number') {\n            return typeof obj[key] == typename;\n        } else {\n            return false; // type not supported\n        }\n    } else {\n        return !mandatory;\n    }\n\n}\n\n\nfunction validateClaimValueIsOneOf(obj, key, valueSet) {\n    if (obj[key] == undefined || valueSet == undefined) { return false; } // misconfiguration lock out.\n    // check if array\n    var match = false;\n\n    for (var vind in obj[key]) {\n        console.log(\"What vind \" + vind);\n        for (var vsind in valueSet) {\n            if (obj[key][vind].toUpperCase() == valueSet[vsind]) {\n                match = true;\n                break;\n            }\n        }\n        if (match == true) break;\n    }\n\n    return match;\n}\n\n\n"
    - gatewayscript:
        version: 2.0.0
        title: jwt-validation
        source: "/* -------------------------------------Code Header ----------------------------------\r\nFilename: privacy-preserving.js\r\nVersion: 3.0.0\r\n\r\nThis script is executed after validate consumer gateway jwt token to make furthur request validation \r\nfor privacy preserving purpose, it will perform the following steps:\r\n\r\n1. validate special fields that mandatory for privacy preserving\r\n2. validate the ROT against RSA(Resource Manager Adapter) and get patient details + permission\r\n3. injert privacy preserving specifed LOB http headers\r\n\r\n  Copyright (c) Ontario Health, 2020\r\n\r\n  This unpublished material is proprietary to Ontario Health.\r\n  All rights reserved. Reproduction or distribution, in whole or in part, \r\n  is forbidden except by express written permission of Ontario Health.\r\n---------------------------------------------------------------------------------------*/\r\nvar console = require('console');\r\nvar crypto  = require('crypto');\r\nvar urlopen = require('urlopen');\r\n\r\nvar logCategory = context.get('api.properties.log-category');\r\nvar logger = console.options({ 'category': logCategory });\r\n\r\n\r\n\r\n/* --------ERROR ref_code DEFINITION BLOCK -------------------------------*/\r\nvar errorref_codes = {\r\n\r\n    'AUTHORIZATION_OAUTH_GTWY_SYSF1': {\r\n      'ref_code': 'GTWY-SYSF1',\r\n      'details': 'oauth-config is not set',\r\n      'status': {\r\n          'code': '500',\r\n          'reason': 'Internal System Error',\r\n      },\r\n      'kind': 'AE',\r\n      'body': ''\r\n  },\r\n\r\n  'AUTHORIZATION_JWT_CLAIMS': {\r\n    'ref_code': 'GTWY-ATH13',\r\n    'details': 'One or more claims in Token could not be verified',\r\n    'status': {\r\n        'code': '401',\r\n        'reason': 'Unauthorized'\r\n    },\r\n    'kind': 'AE',\r\n    'body': ''\r\n  },\r\n\r\n  'RSA_CONNMUNICATION_ERROR': {\r\n      'ref_code': 'GTWY-SYSF3',\r\n      'details': 'Failed to invoke the RSAdapter service',\r\n      'status': {\r\n        'code': '401',\r\n        'reason': 'Unauthorized'\r\n      },\r\n      'kind': 'SE',\r\n      'body': ''\r\n  },\r\n\r\n  'RSA_SERVER_ERROR': {\r\n    'ref_code': 'GTWY-SYSF4',\r\n    'details': 'RSAdapter Internal Server Error',\r\n    'status': {\r\n      'code': '401',\r\n      'reason': 'Unauthorized'\r\n    },\r\n    'kind': 'SE',\r\n    'body': ''\r\n  }\r\n};\r\n\r\n\r\n//get the api setup and current error status\r\nvar privacyIndicator = context.get('api.properties.privacy-preserving-enabled');\r\nvar errorcode = context.get('application.errorcode');\r\nlogger.debug('CG-PREHOOK: privacy-preserving.js is executing with privacy indicate: ' + privacyIndicator + ' and error status: ' + errorcode );\r\n\r\n\r\n// only process the privacy preserving when there is no previous error and the indicator is set to true\r\nif( 'true' === privacyIndicator && ( errorcode == null || errorcode == undefined )) {\r\n  processPrivacyPreserving();\r\n}\r\n\r\n//process the privacy preserving validation\r\nfunction processPrivacyPreserving() {\r\n\r\n  validateClaims();\r\n\r\n  var authError = context.get('application.autherror');\r\n  if( authError != null && authError === true ) {\r\n    logger.debug('CG-PREHOOK: privacy-preserving.js claim validation failed, RPT token validation against RS Adapter will be ignored ! ' );\r\n  }\r\n  else {\r\n     validateRptOnRSA();\r\n  }\r\n}\r\n\r\n\r\n//validate some extra RPT token claims after the standard JTW validations\r\nfunction validateClaims() {\r\n\r\n  //derive the expected api-key based on client id\r\n  var clientId = context.get('client.app.id');\r\n  var validApiKey = crypto.createHash('sha256').update(clientId).digest('base64');  \r\n  var tokenClaims = context.get('App-IntrospectionToken');\r\n  logger.debug('CG-PREHOOK: privacy-preserving.js expected API Key:' + validApiKey );\r\n  \r\n  //load auth config rule for current api unique id\r\n  // TODO: consider to keep the auth-config loading here before call the RSAdapter\r\n  // var authRule = loadAuthConfig();\r\n  // if( authRule['loaded'] == false ) {\r\n  //     errorref_codes.AUTHORIZATION_OAUTH_GTWY_SYSF1.body = authRule['error'];\r\n  //     raiseError(errorref_codes.AUTHORIZATION_OAUTH_GTWY_SYSF1);\r\n  // }\r\n  // else \r\n  \r\n  if( ! isValidClaimPresent(tokenClaims, 'api_keys', validApiKey )) {\r\n      errorref_codes.AUTHORIZATION_JWT_CLAIMS.body = \"APIKey not in Token\";\r\n      raiseError(errorref_codes.AUTHORIZATION_JWT_CLAIMS);\r\n  }\r\n}\r\n\r\n\r\n//load current invokcation auth config\r\nfunction loadAuthConfig() {\r\n\r\n  var authConfig = {\r\n    loaded: false,\r\n    error: ''\r\n  };\r\n\r\n  //derive the api unique id as either api operation id or the api path\r\n  var apiUniqueId = '';\r\n  var apiOperationPath = context.get('api.operation.path');\r\n  var apiOperationId   = context.get('api.operation.id');\r\n  logger.debug('CG-PREHOOK: privacy-preserving.js with operation id: ' + apiOperationId + ' with path: ' + apiOperationPath );\r\n  if( apiOperationId != null && apiOperationId != '') {\r\n     apiUniqueId = apiOperationId;\r\n  }\r\n  else {\r\n     apiUniqueId = apiOperationPath;\r\n  }\r\n\r\n  //load the configured oauth-config and find the rule for current api unique id\r\n  var authConfStr = context.get('api.properties.oauth-config');\r\n  if( authConfStr == null ) {\r\n    logger.error('CG-PREHOOK: privacy-preserving.js loaded NULL for oauth-config, Oauth configuration not set !');\r\n    authConfig.error = 'Oauth configuration not set';\r\n  }\r\n  else { \r\n    var authCfg = JSON.parse(authConfStr);\r\n    if( authCfg == null ) {\r\n      logger.error('CG-PREHOOK: privacy-preserving.js Oauth configuration incorrectly set and cannot be parsed !');\r\n      authConfig.error = 'Oauth configuration incorrectly set and cannot be parsed';\r\n    }\r\n    else {\r\n      var apiVerb = context.get('request.verb');\r\n      var matchedAuthRule = authCfg[apiUniqueId][apiVerb];\r\n      if( matchedAuthRule == null ) {\r\n        logger.error('CG-PREHOOK: privacy-preserving.js Oauth configuration incorrectly set, no rule match request !');\r\n        authConfig.error = 'Oauth configuration incorrectly set, no rule match request';      \r\n      }\r\n      else {\r\n        authConfig['scope']   = matchedAuthRule['scope'];\r\n        authConfig['profile'] = matchedAuthRule['profile'];\r\n        authConfig['loaded']  = true;\r\n        logger.debug('CG-PREHOOK: privacy-preserving.js loaded the matched auth rule: ' + JSON.stringify(authConfig));\r\n      }\r\n    }\r\n  }\r\n\r\n  return authConfig;\r\n}\r\n\r\n//check if the permission claim authorized \r\nfunction isClaimAuthorized(authRule, rsaResponse) {\r\n   var claimAuthorized  = false;\r\n   var tokenPermissions = rsaResponse['permissions'];\r\n \r\n   if(tokenPermissions != null && Array.isArray( tokenPermissions )) {\r\n\r\n      var countOfPermissions = tokenPermissions.length;\r\n      var configuredProfile = authRule['profile'];\r\n      var configuredScopes  = authRule['scope'];\r\n    \r\n      for( var index=0; index < countOfPermissions; index++) {\r\n        \r\n          logger.debug();\r\n          var permission = tokenPermissions[index];\r\n          var resourceType = permission['resource_type'];\r\n          var scopeArray = permission['resource_scopes'];\r\n    \r\n          logger.debug('CG-PREHOOK: privacy-preserving.js validate permission group ' + index + ' with resource type: ' + resourceType + ' with scopes: ' + scopeArray );\r\n    \r\n          if( configuredProfile === resourceType && isArrayOverlapping(configuredScopes, scopeArray )) {\r\n              claimAuthorized = true;\r\n              break;\r\n          }\r\n      }\r\n   }   \r\n\r\n   return claimAuthorized;\r\n}\r\n\r\n\r\n//return false if any matching occurs\r\nfunction isArrayOverlapping(claimValues, expectedValues ) {\r\n\r\n  var overlapping = false;\r\n\r\n  claimValues.some( claimItem => {\r\n      expectedValues.some( expectedItem => {         \r\n         if( claimItem === expectedItem ) {\r\n           overlapping = true;\r\n         }\r\n         return overlapping;\r\n      });\r\n      return overlapping;\r\n  }) ;\r\n  return overlapping;\r\n}\r\n\r\n\r\n\r\n// validate RPT token against RS adapter, no need to use promise\r\nfunction validateRptOnRSA() {\r\n\r\n  //get the original client request's base64 RPT token as RSA request payload\r\n  var rptToken = {'token': context.get('request.authorization').split(\"Bearer \")[1] };\r\n  var request  = JSON.stringify(rptToken);\r\n  logger.debug('CG-PREHOOK: privacy-preserving.js request sent to RS Adapter is: ' + request );\r\n\r\n  var rsadapterURL = context.get('api.properties.rsadapter-url');\r\n  var tlsProfile   = context.get('api.properties.rsadapter-tls-profile');\r\n \r\n  var httpOptions = {\r\n    target: rsadapterURL,\r\n    method: 'post',\r\n    headers: { \r\n      'Content-Type': 'application/json'\r\n    },\r\n    contentType: 'application/json',\r\n    data: request,\r\n    sslClientProfile: tlsProfile\r\n  }; \r\n  logger.debug('CG-PREHOOK: privacy-preserving.js is about to call rsadapter at ' + rsadapterURL + ' with ssl profile ' + tlsProfile  );\r\n\r\n  //invoke the RSAdapter\r\n  urlopen.open( httpOptions, function ( error, response ) {\r\n\r\n      if ( error ) {\r\n        logger.error('CG-PREHOOK: failed to conmunicate with RSAdapter: ' + JSON.stringify(error) ); \r\n        errorref_codes.RSA_CONNMUNICATION_ERROR.body = \"failed to invoke rs adapter service due to connmunication error\";\r\n        raiseError( errorref_codes.RSA_CONNMUNICATION_ERROR );\r\n      }\r\n      else {\r\n        var responseStatusCode   = response.statusCode;\r\n        var responseReasonPhrase = response.reasonPhrase;\r\n\r\n        logger.debug(\"CG-PREHOOK: privacy-preserving.js invoke RS Adapter with HTTP \" + responseStatusCode + ' ' + responseReasonPhrase);\r\n\r\n        if ( responseStatusCode == 200 ) {\r\n            response.readAsJSON( function (error, rsaResponse) {\r\n                if (error) {\r\n                  errorref_codes.RSA_CONNMUNICATION_ERROR.body = \"failed to read rs adapter response due to json parsing error\";\r\n                  raiseError( errorref_codes.RSA_CONNMUNICATION_ERROR );\r\n                }\r\n                else {\r\n                  processRSAdapterResponse( rsaResponse );\r\n                }\r\n            });\r\n        }\r\n        else {\r\n          errorref_codes.RSA_SERVER_ERROR.body = 'RSAdapter internal error HTTP ' + responseStatusCode + ' ' + responseReasonPhrase;\r\n          raiseError( errorref_codes.RSA_SERVER_ERROR );\r\n        }\r\n      }\r\n  });\r\n}\r\n\r\n//process the RSAdapter response presented in json format\r\nfunction processRSAdapterResponse( rsaResult ) {\r\n\r\n  logger.debug('CG-PREHOOK: privacy-preserving.js is processing RSAdapter response: ' + JSON.stringify(rsaResult));\r\n\r\n  var active = rsaResult['active'];\r\n  if( active == true ) {\r\n\r\n    var authRule = loadAuthConfig();\r\n\r\n    if( authRule['loaded'] == false ) {\r\n        errorref_codes.AUTHORIZATION_OAUTH_GTWY_SYSF1.body = authRule['error'];\r\n        raiseError(errorref_codes.AUTHORIZATION_OAUTH_GTWY_SYSF1);\r\n    }\r\n    else if( ! isClaimAuthorized(authRule, rsaResult) ) {\r\n        errorref_codes.AUTHORIZATION_JWT_CLAIMS.body = \"RPT Token permissions does not contain expected resoruce-id and scope\";\r\n        raiseError(errorref_codes.AUTHORIZATION_JWT_CLAIMS);\r\n    }\r\n    else {\r\n      var tokenClaims = context.get('App-IntrospectionToken');\r\n      tokenClaims['patient'] = rsaResult['owner_info'];\r\n      context.set('App-IntrospectionToken', tokenClaims);\r\n    }\r\n  }\r\n  else {\r\n    var rejectDetails = 'RSAdapter rejected RPT token wiht error code: ' + rsaResult['error'] + ', error message: ' + rsaResult['error_description'];\r\n    logger.debug('CG-PREHOOK: privacy-preserving.js ' + rejectDetails );\r\n    errorref_codes.AUTHORIZATION_JWT_CLAIMS.body    = rejectDetails;\r\n    errorref_codes.AUTHORIZATION_JWT_CLAIMS.details = 'One or more claims in Token could not be verified against RSAdapter';\r\n    raiseError( errorref_codes.AUTHORIZATION_JWT_CLAIMS );\r\n  }\r\n}\r\n\r\n\r\n//check if the expected value match the specified claim field (single or array)\r\n//return true if the expected value matches the claim field\r\n//return false if expected value does not match the claim field, or any element of the specified claim array\r\nfunction isValidClaimPresent(claims, fieldName, expectedValue ) {\r\n  var claimValid = false;\r\n  var fieldValue = claims[fieldName];\r\n\r\n  logger.debug('CG-PREHOOK: privacy-preserving.js  validate field ' + fieldName + ' with expected [' + expectedValue + '] against ' + fieldValue );\r\n\r\n  if(  fieldValue != null ) {\r\n\r\n    if( Array.isArray( fieldValue )) {\r\n      fieldValue.some( item => {\r\n        if( item === expectedValue ) {\r\n            claimValid = true;\r\n        }\r\n        return claimValid;\r\n      });\r\n    }\r\n    else if( fieldValue === expectedValue ) {\r\n        claimValid = true;\r\n    }    \r\n  }\r\n\r\n  return claimValid;\r\n}\r\n\r\n// thie function set error context variable to indicate application failure\r\nfunction raiseError( errorcode ) {\r\n  context.set('application.autherror', true );\r\n  context.set('application.errorcode', errorcode );\r\n  logger.debug('PG-PREHOOK: privacy-preserving.js, Raising Error : ' + errorcode.ref_code + \" Details: \" + errorcode.body);\r\n}"
    - gatewayscript:
        version: 2.0.0
        title: gws-inject-lob-headers
        source: "/* -------------------Code Header -------------------------------\n    Filename: injectlobheaders.js\n    Version: 1.0.0\n    Last Updated: \n          \n    Feb 19 2020: Now will send JSON token to backend\n    Nov 21 : X-GtwyOriginalURIMasked is now only up to the base path\n             compatibility is offered for olis if compatiblity mode flag is on.\n    Nov 14: Added X-Intermediary header\n     Description: Generate the parameters used in request tracking\n\n **************************************************************\n    Copyright (c) ehealthOntario, 2019\n\n    This unpublished material is proprietary to ehealthOntario.\n    All rights reserved. Reproduction or distribution, in whole \n    or in part, is forbidden except by express written permission \n    of ehealthOntario.\n    **************************************************************\n-------------------------------------------------------------------*/\nvar console = require('console');\nvar apim = require('apim');\nvar lcategory = context.get('api.properties.log-category');\nvar logger = console.options({ 'category': lcategory });\nvar configurationObject = context.get('dhcg-configuration');\nvar xintermediaryvalue = context.get('api.properties.xintermediary');\n\nvar errorref_codes = {\n    'SYSTEMCONFIG': {\n        'ref_code': 'GTWY-SYSF1',\n        'details': 'OAG-CG System configuration invalid',\n        'status': {\n            'code': '500',\n            'reason': 'System Internal Error'\n        },\n        'kind': 'SE',\n        'body': 'api.properties.xintermediary not set'\n    }\n};\n\n// if error codes raised then return from this script\nvar errorcodes = context.get('application.errorcode');\nif (errorcodes != null) {\n    return; // stop processing\n}\n\n\nvar transactionID = context.get('message.headers.x-global-transaction-id');\ncontext.set('message.headers.X-GtwyTxId',\n    transactionID);\n\nif (xintermediaryvalue != null && xintermediaryvalue != \"\") {\n    context.set('message.headers.X-Intermediary', xintermediaryvalue);\n} else {\n    // raise error - doesn't immediately reject\n    context.set('application.errorcode', errorref_codes.SYSTEMCONFIG);\n}\n\n\n\n\nvar maskedURI = getRequestPathMasked();\nif (configurationObject.compatibilitymode) {\n    var legacyMaskedURI = getRequestPathMaskedLegacy();\n    logger.debug(\"CG-PREHOOK: injectlobheaders.js LEGACYMaskedURI: \" + legacyMaskedURI);\n\n    context.set('message.headers.GtwyOriginalRequestUriMasked', legacyMaskedURI);\n\n    if (legacyMaskedURI == null) {\n        var templateLog = context.get('dhcg-logging');\n        templateLog.errorcode = \"GTWY-SYSL0\";\n        templateLog.errordetails = \"Could not parse the request URI\";\n        logger.error(JSON.stringify(templateLog));\n    }\n}\n\nif (maskedURI == null) {\n    var templateLog = context.get('dhcg-logging');\n    templateLog.errorcode = \"GTWY-SYSL0\";\n    templateLog.errordetails = \"Could not parse the request URI for X-GtwyOriginalRequestUriMasked\";\n    logger.error(JSON.stringify(templateLog));\n}\n\ncontext.set('message.headers.X-GtwyOriginalRequestUriMasked', maskedURI);\n\nlogger.debug(\"CG-API: injectlobheaders.js MaskedURI: \" + maskedURI);\n\n\n// added this to catch problems, but no error to client, silent log.\nif (maskedURI == null) {\n    var templateLog = context.get('dhcg-logging');\n    templateLog.errorcode = \"GTWY-SYSL0\";\n    templateLog.errordetails = \"Could not parse the request URI\";\n    logger.error(JSON.stringify(templateLog));\n}\n\n// X-forward-for logic testing \n\n//context.set(\"message.headers.GtwyOriginalClientIP\", apim.getvariable('message.headers.X-Client-IP'));\n//console.error(\"message.headers.X-Client-IP: \" +  apim.getvariable('message.headers.X-Client-IP'));\n//console.error(\"request.headers.X-Client-IP: \" +  apim.getvariable('request.headers.X-Client-IP'));\n\n//console.error(\"request.headers.X-Forwarded-For: \" + context.get('request.headers.X-Forwarded-For'));\n//console.error(\"message.headers.X-Forwarded-For: \" + context.get('message.headers.X-Forwarded-For'));\n\nvar xforward = context.get('request.headers.X-Forwarded-For');\nif (xforward == null || xforward == \"\") {\n    // we inject our own, host name\n    xforward = apim.getvariable('message.headers.X-Client-IP');\n} \n// OAG-365\n//xforward +=\", \" + xintermediaryvalue;\nxforward +=\", \" + context.get('api.endpoint.address');\ncontext.set('message.headers.X-Forwarded-For', xforward);\n\n// X-Forwarded-Host header\nvar G_HOST_HEADER = context.get('request.headers.host');\nvar xhost = G_HOST_HEADER.split(\":\")[0];\ncontext.set('message.headers.X-Forwarded-Host', xhost);\n\nlogger.debug(\"CG-PREHOOK: injectlobheaders.js X-Forwarded-For: \" + xforward + \" X-Forwarded-Host: \" + xhost);\n\n// emulate use new logic\n/*if (!configurationObject.compatibilitymode) {\n    putLOBBearerToken();\n}*/\nputLOBBearerToken();\n\nfunction getRequestPathMasked() {\n    var root = context.get('api.root');\n\n    var fullPath = \"https://\" + context.get('api.endpoint.hostname') + \"/\" +\n        context.get('api.org.name') + \"/\" + context.get('api.catalog.path');\n    if (root != null && root.length > 0 && root != \"/\") {\n        fullPath += root;\n    }\n    return fullPath;\n}\n\n\n/** Legacy Function with $ fixed */\nfunction getRequestPathMaskedLegacy() {\n    var requestURI = context.get('request.uri');\n    var apiPath = context.get('api.root') + context.get('api.operation.path');\n    var p = requestURI.indexOf(apiPath);\n    if (p < 0) {\n        return \"error\";\n    }\n    // now we have to replace the data with host, so \n    // 1 need to match the host in the request.headers.host  \n    // 2 need to match the http scheme\n    // 3 take evertthing starting and including the 3rd / character\n    var extractedURI = requestURI.substring(0, p + apiPath.length);\n    var scheme = requestURI.match('^http(s)?://')[0];\n    return scheme + context.get('request.headers.host') + extractedURI.substring(extractedURI.indexOf('/', 8));\n}\n\n\n\n\n\nfunction putLOBBearerToken() {\n\n    var outputClaims = context.get(\"App-IntrospectionToken\");\n    var stringClaims = JSON.stringify(outputClaims);\n    var bufferClaims = Buffer.from(stringClaims);\n    if (configurationObject.test_mode != null) logger.debug(\"CG-PREHOOK: injectlobheaders.js ProcessedToken \" + stringClaims);\n\n    var b64Token = bufferClaims.toString('base64url');\n    var fullAuthHeader = \"Bearer \" + b64Token;\n    logger.debug(\"Backend Token: \" + fullAuthHeader);\n    context.set('message.headers.Authorization', fullAuthHeader);\n}\n\n"
